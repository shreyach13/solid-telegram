Cluster Management

Autoscaling

Kubernetes offers two layers of scalability for PODs:

● Pods layer autoscalers Horizontal Pod Autoscaler (HPA) and Vertical Pod Autoscaler (VPA) with both scale available resources to your containers

● Cluster level scalability which managed by the Cluster Autoscaler (CA) that scales up or down the number of nodes inside of your cluster

Scalability features need extra settings in yaml.

Scaling additional nodes, looks for "pending" pods, and if seen, k8s will attempt to add a new node.

k8s is very metric driven, so if pod/node usage metrics dictate, pods may be scaled up/down and nodes may be added/removed...

https://medium.com/magalix/kubernetes-autoscaling-101-cluster-autoscaler-horizontal-pod-autoscaler-and-vertical-pod-2a441d9ad231

Kubernetes Scheduler

Scheduling refers to Pods being matched to Nodes in order for kubelet to run them Kube-Scheduler

● Filtering
   - Find set of Nodes that the Pod can be scheduled
● Scoring
   - Scheduler ranks the remaining Nodes to find the next more suitable

Current setup of K8s
$ more ~/.kube/config

Working with AWS eks

Sets up the K8s config to allow communication with cluster (jt-shell)

Changing Contexts (between local docker and eks)

$ aws eks update-kubeconfig --name jt-shell --region eu-central-1
Added new context arn:aws:eks:eu-central-1:426714351745:cluster/jt-shell to /Users/paul.broughton/.kube/config

$ kubectl config use-context docker-desktop
Switched to context "docker-desktop".
$ kubectl get pods --all-namespaces
NAMESPACE     NAME                                     READY   STATUS    RESTARTS   AGE
docker        compose-6c67d745f6-kfrz2                 1/1     Running   0          23h
docker        compose-api-57ff65b8c7-pjzzk             1/1     Running   0          23h
kube-system   coredns-fb8b8dccf-m7c9w                  1/1     Running   0          23h
kube-system   coredns-fb8b8dccf-z6l8z                  1/1     Running   0          23h
kube-system   etcd-docker-desktop                      1/1     Running   0          23h
kube-system   kube-apiserver-docker-desktop            1/1     Running   0          23h
kube-system   kube-controller-manager-docker-desktop   1/1     Running   0          23h
kube-system   kube-proxy-gkr4b                         1/1     Running   0          23h
kube-system   kube-scheduler-docker-desktop            1/1     Running   0          23h

$ kubectl config use-context arn:aws:eks:eu-central-1:426714351745:cluster/jt-shell
Switched to context "arn:aws:eks:eu-central-1:426714351745:cluster/jt-shell".


Setup the K8s Dashboard
$ kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/master/src/deploy/alternative/kubernetes-dashboard.yaml

$ kubectl proxy

$ kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/master/src/deploy/alternative/kubernetes-dashboard.yaml

Example HPA

# Create a working namespace
$ kubectl create namespace pauls-ns
namespace/pauls-ns created

# Setup the limits for the pod
$ k run php-apache -n pauls-ns --image=k8s.gcr.io/hpa-example --requests=cpu=200m --expose --port=80
kubectl run --generator=deployment/apps.v1 is DEPRECATED and will be removed in a future version. Use kubectl run --generator=run-pod/v1 or kubectl create instead.
service/php-apache created
deployment.apps/php-apache created

# Create a HPA deployment policy
$ kubectl autoscale deployment php-apache -n pauls-ns --cpu-percent=50 --min=1 --max=10
horizontalpodautoscaler.autoscaling/php-apache autoscaled

# View the created HPA
$ k get hpa
NAME         REFERENCE               TARGETS         MINPODS   MAXPODS   REPLICAS   AGE
php-apache   Deployment/php-apache   <unknown>/50%   1         10        1          79s

# Run a POD in the namespace that we can then run a load generator on...
$ kubectl run -i --tty load-generator -n pauls-ns --image=busybox /bin/sh

Looking at the CA example
$ wget https://eksworkshop.com/scaling/deploy_ca.files/cluster_autoscaler.yml
$ more cluster_autoscaler.yml

$ k get pods -n kube-system
$ k logs cluster-autoscaler-6dcf6fdd-hr9qq -n kube-system

# Latest example
$ vi nginx.yaml
$ k apply -n pauls-ns -f nginx.yaml
deployment.extensions/nginx-to-scaleout created

$ kubectl get deployment/nginx-to-scaleout -n pauls-ns
NAME                READY   UP-TO-DATE   AVAILABLE   AGE
nginx-to-scaleout   0/1     1            0           26s

$ kubectl scale --replicas=10 deployment/nginx-to-scaleout -n pauls-ns
deployment.extensions/nginx-to-scaleout scaled

$ kubectl get pods -o wide --watch -n pauls-ns
..

$ k delete deployments nginx-to-scaleout -n pauls-ns


Services
● Services Types
- ClusterIP         - Not exposed outside the k8s cluster (internal only)
- NodePort          - Exposes a ephemeral IP (>32000) to access service
- LoadBalancer      - Similar to NodePort but does same for all nodes in EKS Cluster

● Provide:
- Find pods by label selector
- Load Balancing
- Service Discovery

# Replace a setup in place (slightly different than apply)
$ k replace -f $YAML_FILE


To communicate with a Pod within the cluster, you can use the object name and the namespace (and you must be in the cluster) ie.

$ curl nginx-service.default

Connect to nginx-service in the default namespace


Kubernetes Security
● RBAC
  - much more powerful and resilient nowadays
● NetworkPolicy
  - Typical aspects for nACLS
● TLS
  - Everything is secure in k8s using TLS
● Image Scanning
  - CLAIR - step in the pipelime to ensure images are clean (from security)
● Aquasec/Twistlock
  - additional commercial securoty tools
● Prowler
  - Looks more at k8s infractructure (similar to Docker benchmark??)
● Integrating with HashiCorp Vault other public cloud secret stores ie. AWS Secrets manager
